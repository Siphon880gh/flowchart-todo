<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flowchart Todo - Teamspace</title>
    <style>
        #svg-container {
          width:100%;
          height:100%;
          overflow: visible;
        }
        #svg-container, svg {
            position: relative;
            z-index: 1;
        }
        #svg-container svg {
          width:100%;
          height:100%;
          overflow: visible;
        }
        .svg-checkbox {
            position: absolute;
            z-index: 2;
        }
  </style>
</head>
<body>
    <h1>Flowchart Todo</h1>
    <div style="display:block; top:0; left:0;"><button data-svg-zoomer>Zoom</button></div>
    <!-- TOOLER: Add "data-checkbox" attribute to svg children you want to have floating checkboxes that your team ticks -->
    <!-- TOOLER: If want zoom feature to work, make sure sure to remove width and height attributes
                 and set the pixels in the viewBox attribute in this format: "0 0 width height"
                 <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 430 320" preserveAspectRatio="xMidYMid meet">
    -->
    <div id="svg-container">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 430 320" preserveAspectRatio="xMidYMid meet">
            <!-- Rectangle (Start) -->
            <rect x="50" y="20" width="120" height="40" fill="lightblue" stroke="black" data-checkbox />
            <text x="110" y="45" text-anchor="middle" font-size="14" fill="black">Start</text>
            
            <!-- Arrow (Start to Process) -->
            <path d="M110,60 L110,100" stroke="black" marker-end="url(#arrowhead)" />
            
            <!-- Rectangle (Process) -->
            <rect x="50" y="100" width="120" height="40" fill="lightgreen" stroke="black" data-checkbox />
            <text x="110" y="125" text-anchor="middle" font-size="14" fill="black">Process</text>
            
            <!-- Arrow (Process to Decision) -->
            <path d="M110,140 L110,180" stroke="black" marker-end="url(#arrowhead)" />
            
            <!-- Diamond (Decision) -->
            <polygon points="110,200 140,220 110,240 80,220" fill="lightyellow" stroke="black" data-checkbox />
            <text x="110" y="225" text-anchor="middle" font-size="14" fill="black">Decision</text>
            
            <!-- Arrow (Decision to End) -->
            <path d="M140,220 L200,220" stroke="black" marker-end="url(#arrowhead)"/>
            
            <!-- Rectangle (End) -->
            <rect x="200" y="200" width="120" height="40" fill="lightcoral" stroke="black" data-checkbox />
            <text x="260" y="225" text-anchor="middle" font-size="14" fill="black">End</text>
            
            <!-- Arrowhead definition -->
            <defs>
                <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="0" refY="3.5" orient="auto">
                    <polygon points="0 0, 10 3.5, 0 7" fill="black" />
                </marker>
            </defs>
        </svg>
    </div> <!-- .svg-container -->


    <script>
      const App = {
          init: function() {
            console.log("App.init");
            this.validateSVG();
            this.initZoom();
            
            this.initRepainters();
            this.attachCheckboxes();

            this.initCollab();
          },
          _zoomFactor: -1,
          validateSVG: function() {
            if(!document.querySelector("#svg-container svg").getAttribute("viewBox")) { console.error("ERROR - SVG element missing 'viewBox' attribute needed for Flowchart Todo."); }
            if(!document.querySelector("#svg-container svg").getAttribute("preserveAspectRatio")) { console.error("ERROR - SVG element missing 'preserveAspectRatio' attribute needed for Flowchart Todo."); }
          },
          initZoom: function() {
            document.querySelector('[data-svg-zoomer]')?.addEventListener('click', ()=>{
              this._zoomFactor += 1;
              switch((this._zoomFactor+1)%8) {
                case 1: document.querySelector("#svg-container svg").style.width = "125%"; break;
                case 2: document.querySelector("#svg-container svg").style.width = "150%"; break;
                case 3: document.querySelector("#svg-container svg").style.width = "175%"; break;
                case 4: document.querySelector("#svg-container svg").style.width = "200%"; break;
                case 5: document.querySelector("#svg-container svg").style.width = "50%"; break;
                case 6: document.querySelector("#svg-container svg").style.width = "75%"; break;
                case 7: document.querySelector("#svg-container svg").style.width = "100%"; break;
              }
              window.dispatchEvent(new Event('resize'));
            });
          }, // initZoom
          _getCoords: function(el) {
              // Different methods of getting the coordinates are retained here in case edge cases of some SVG elements could glitch the coordinates. In testing phase.
              var a = el?.getBoundingClientRect()
              var b = el?.getBBox();
              var c = el?.getClientRects()?.[0];

              //
              const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
              const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;

              var svg = document.querySelector("#svg-container svg");
              let pt = svg.createSVGPoint();
              pt.x = 0; // Needed to get the coordinate of the start of the path
              pt.y = 0;
              let firstMove = el.getAttribute('d').match(/M\s*([-\d.]+)\s*,\s*([-\d.]+)/);
              if (firstMove) {
                  pt.x = parseFloat(firstMove[1]);
                  pt.y = parseFloat(firstMove[2]);
              }
              // Manually adjust the point based on the viewBox
              const viewBox = svg.viewBox.baseVal;  // This gets the viewBox as an SVGRect object
              // Adjust the point if necessary, e.g., translate it
              pt.x = viewBox.x;
              pt.y = viewBox.y;
              var screenCTM = el.getScreenCTM();
              var d = pt.matrixTransform(screenCTM);

              console.log("Positioning", {el,a,b,c,d,firstMove,screenCTM:el.getScreenCTM(),baseVal:svg.viewBox.baseVal,scrollLeft,scrollTop});

              return {
                x: c.x + scrollLeft,
                y: c.y + scrollTop
              }


              // Create an SVG point where you want to measure the coordinates
              // var svg = document.querySelector("#svg-container svg");
              // var path = el;

              // let pt = svg.createSVGPoint();
              
              // // Assuming you want the coordinate of the start of the path
              // let dAttr = path.getAttribute('d');
              // let firstCoordMatch = dAttr.match(/M\s*([-\d.]+)\s*,\s*([-\d.]+)/);
              // if (firstCoordMatch) {
              //     pt.x = parseFloat(firstCoordMatch[1]);
              //     pt.y = parseFloat(firstCoordMatch[2]);
              // } else {
              //     console.error('No move command found in path d attribute.');
              //     return;
              // }

              // // Convert this point to the screen coordinate system
              // let screenCTM = path.getScreenCTM();
              // if (screenCTM) {
              //     let position = pt.matrixTransform(screenCTM);

              //     // Adjust for current scroll position to get absolute coordinates
              //     const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
              //     const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;

              //     const absoluteX = position.x + scrollLeft;
              //     const absoluteY = position.y + scrollTop;

              //     console.log("Absolute X: ", absoluteX);
              //     console.log("Absolute Y: ", absoluteY);
              
              //     return {
              //       x: absoluteX,
              //       y: absoluteY
              //     }
              // } else {
              //     console.error('Could not retrieve the transformation matrix.');
              // }

          }, // _getCoords
          attachCheckboxes: function() {
              const svg = document.getElementsByTagName('svg')[0];
              const svgContainer = document.getElementById('svg-container');
              const svgDrawings = svg.querySelectorAll('[data-checkbox]');
              svgDrawings.forEach(svgDrawing => {
                  // const bbox = element.getBBox(); // can be inaccurate even after render
                  const bbox = this._getCoords(svgDrawing);
                  if(!bbox) {
                    console.error("Could not get bounding box for SVG element", {svgDrawing})
                    return
                  }
                  const checkbox = document.createElement('input');
                  checkbox.type = 'checkbox';
                  checkbox.classList.add('svg-checkbox');
                  checkbox.setAttribute('paired', svgDrawing.getAttribute("paired")); // <input... paired="0">
                  checkbox.style.left = `${bbox.x}px`;
                  checkbox.style.top = `${bbox.y}px`;
                  svgContainer.appendChild(checkbox);
              });
          }, // attachCheckboxes
          initRepainters: function() {

              // Assign unique child classes to each SVG child element
              // This is to pair the checkbox with the SVG element
              // So when you resize the window, the checkbox moves with the SVG element
              const svg = document.getElementsByTagName('svg')[0];
              const svgDrawings = svg.querySelectorAll('[data-checkbox]');
              for(var i = 0; i<svgDrawings.length; i++) {
                  var svgDrawing = svgDrawings[i];
                  svgDrawing.setAttribute(`paired`, i); // // <rect... paired="0">
              }
              
              window.addEventListener("resize", (event)=>{
                console.log("resized")
                  const checkboxes = document.querySelectorAll('.svg-checkbox');
                  console.log("resize->reposition checkbox", {checkboxes})
                  checkboxes.forEach(checkbox => {
                    var pairIndex = checkbox.getAttribute("paired");
                    console.log("resize->reposition checkbox", {pairIndex})
                    var pairedSvgDrawing = document.querySelector(`[paired="${pairIndex}"]:not(input)`);
                    // var bbox = pairedSvgDrawing.getBoundingClientRect();
                    const bbox = this._getCoords(pairedSvgDrawing);
                    checkbox.style.left = `${bbox.x}px`;
                    checkbox.style.top = `${bbox.y}px`;
                  });
              })
          }, // initRepainters
          initCollab() {

            // When the page loads, read the checked indexes
            fetch("logic/read.php")
            .then(response=>response.json())
            .then((obj) => {
                // console.log({obj});
                // console.log(obj.current); 

                var checkmarks = obj.checkmarks;
                checkmarks = JSON.parse(checkmarks);

                checkmarks.forEach((checkmarkPos) => {
                  var test = document.querySelectorAll("input.svg-checkbox")?.[checkmarkPos];
                  if(test)
                    test.checked = true; 
                })
            }); // fetch


            // When a checkbox is checked, save the checked indexes
            document.querySelectorAll("input.svg-checkbox").forEach((el) => {
              el.addEventListener("change", (event) => {
                var checkmarks = [];
                document.querySelectorAll("input.svg-checkbox").forEach((el, i) => { if (el.checked) checkmarks.push(el.getAttribute("paired")); });
                checkmarks = JSON.stringify(checkmarks);
                console.log("Collab checkmarks", checkmarks);

                fetch("logic/write.php", {
                  method: "POST",
                  headers: {
                      'Content-Type': 'application/json'
                  },
                  body: JSON.stringify({ checkmarks })
                }).then(response=>response.text())
                .then((res) => { console.log(res); });
              });
            });
          } // initCollab
      }; // App

      document.addEventListener('DOMContentLoaded', () => {
        App.init(); 

        // setTimeout(()=>{
        //   window.dispatchEvent(new Event('resize'));
        // }, 2000);
      });
    </script>
</body>
</html>
